(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{253:function(e,o,r){"use strict";r.r(o);var n=r(1),s=Object(n.a)({},function(){var e=this,o=e.$createElement,r=e._self._c||o;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[e._v("JavaScript中的异步编程 ---- Promise")]),e._v(" "),r("p",[e._v("了解JavaScript的异步编程之前需要先学习"),r("a",{attrs:{href:"https://blog.webhbz.com/Pages/eventloop.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("JavaScript的有关运行机制"),r("OutboundLink")],1),e._v("\n为了在整体上有个充分的认识，可以先阅读一下知乎上的这篇"),r("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/66593213",target:"_blank",rel:"noopener noreferrer"}},[e._v("文章"),r("OutboundLink")],1),e._v("，相对简单便于理解。")]),e._v(" "),r("h2",{attrs:{id:"什么是promise"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是promise","aria-hidden":"true"}},[e._v("#")]),e._v(" 什么是Promise")]),e._v(" "),r("p",[e._v("Promise最早由社区提出，是用来解决回调地狱的方案，ES6 将其写进了语言标准，统一了用法，原生提供了"),r("code",[e._v("Promise")]),e._v("对象。")]),e._v(" "),r("blockquote",[r("p",[e._v("所谓的"),r("code",[e._v("Promise")]),e._v("，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。   ---- 《ECMAScript 6 入门》")])]),e._v(" "),r("p",[e._v("Promise对象在创建后，就会创建内部状态机，Promise对象代表了一个异步操作，而状态机就包含了这个异步操作的状态，"),r("code",[e._v("pendding")]),e._v("，"),r("code",[e._v("fulfilled")]),e._v("，"),r("code",[e._v("rejected")]),e._v("，\n在"),r("code",[e._v("Promise")]),e._v("对象中，只会存在上述三种状态中的一种，且为不可逆的，不受外界影响。")]),e._v(" "),r("h2",{attrs:{id:"创建promise"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#创建promise","aria-hidden":"true"}},[e._v("#")]),e._v(" 创建Promise")]),e._v(" "),r("p",[e._v("在ES6中有原生的Promise构造函数，使用关键字"),r("code",[e._v("new")]),e._v(" 来创建一个"),r("code",[e._v("Promise")]),e._v("对象。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const promise = new Promise ((resolve,reject) => { // 构造函数接受一个函数为参数，将这个参数暂名为'fn' ，'fn'又接受两个参数，且均为函数\n  const flag = Math.random() > .5 ? true : false ;\n  if(flag) {\n    console.log('使用resolve将promise状态从pending变为resolved');\n    resolve('大于0.5')\n  } else {\n    console.log('使用reject将promise状态从pending变为rejected')\n    reject('小于0.5')\n  }\n})\n\n\npromise.then((resolve) => {\n  console.log(resolve)  // -- '大于0.5'\n},(reject) => {\n  console.log(reject)  // -- '小于0.5'\n})\n\n")])])]),r("p",[e._v("我们来一点点拆分这个"),r("code",[e._v("Promise")]),e._v("，她接收了一个函数，而这个函数又有两个参数"),r("code",[e._v("resolve")]),e._v("，"),r("code",[e._v("reject")]),e._v("，这两个参数都是Promise为我们创建好的"),r("code",[e._v("函数")]),e._v("。这两个函数的作用就是将"),r("code",[e._v("Promise")]),e._v("的状态从"),r("code",[e._v("pending")]),e._v("（等待）转换为"),r("code",[e._v("resolved")]),e._v("（已解决）或者从"),r("code",[e._v("pending")]),e._v("（等待）转换为"),r("code",[e._v("rejected")]),e._v("（已失败）。\n而在Promise创建后，有一些自身的方法。这里先只说"),r("code",[e._v("then")]),e._v("，该方法接受两个"),r("code",[e._v("函数")]),e._v("作为参数，这里就和上面传入Promise的构造函数中的参数函数（"),r("code",[e._v("fn")]),e._v("）的两个参数（"),r("code",[e._v("resolve")]),e._v(","),r("code",[e._v("reject")]),e._v("）对应上了。很显然，"),r("code",[e._v("then")]),e._v("方法的第一个参数函数，接收到"),r("code",[e._v("resolve")]),e._v("传递出的数据，而第二个参数就接收到了"),r("code",[e._v("reject")]),e._v("传递出的数据。\n那么"),r("code",[e._v("Promise")]),e._v("是怎么解决异步操作的回调地狱呢？简单的说就是用"),r("code",[e._v("Promsie")]),e._v("对象包裹一个异步操作，异步操作只在"),r("code",[e._v("Promise")]),e._v("对象内部，不受外部影响同时也不阻塞外部，在这个异步操作有了结果后，通过"),r("code",[e._v("then")]),e._v("方法和外部进行数据传递。如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const promise = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        Math.random() > 0.5 ? resolve('success') : reject('fail');\n    }, 1000)\n});\n\n\npromise.then((result) => {\n    console.log(result);\n}, (err) => {\n    console.log(err);\n});\n\n")])])])])},[],!1,null,null,null);o.default=s.exports}}]);