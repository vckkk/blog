---
title: 积累·1117
date: 2019-11-17
lang: ch-CN
tags:
  - JavaScript
---

成年人的成长在于一次次的积累

<!-- more -->

# 深度优先遍历和广度优先遍历
简单了解两种遍历方式的定义,实现以及不同点.
## 深度优先遍历
Depth-First-Search(DFS),深度优先遍历属于图算法的一种,其过程简单的说就是对每一个可能的分支路径深入到不能再深入为止,且每个节点只能访问一次.
基本思路:
从图的某一个顶点v开始访问:
- 访问顶点v;
- 依次从v的未被访问的邻接点出发，对图进行`深度优先遍历`；直至图中和v有路径相通的顶点都被访问；
- 此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行`深度优先遍历`，直到图中所有顶点均被访问过为止。

```html
<body>
  <div class="parent">
    <div class="child-1">
      <div class="child-1-1">
        <div class="child1-1-1">
          a
        </div>
      </div>
      <div class="child-1-2">
        <div class="child-1-2-1">
          b
        </div>
      </div>
      <div class="child-1-3">
        c
      </div>
    </div>
    <div class="child-2">
      <div class="child-2-1">
        d
      </div>
      <div class="child-2-2">
        e
      </div>
    </div>
    <div class="child-3">
      <div class="child-3-1">
        f
      </div>
    </div>
  </div>
</body>
```
针对上面的`HTML`片段.使用深度优先遍历方式访问所有节点.

```js
let deep2 = (node) => {
  let stack = []; //创建一个栈,进出都在栈顶完成.我们用数组模拟栈，数组尾部为栈顶
  let nodeList = [];
  if (node) {
    stack.push(node); // 将节点放置栈中.
    while (stack.length) { //当栈中有数据时
      let item = stack.pop(); // 将栈顶数据推出(第一次操作即取节点组的根节点出来)
      nodeList.push(item); // 将栈顶数据放置list中
      let children = item.children || item[0].children || []; // 取栈顶节点的子节点 
      for (let i = children.length - 1; i >= 0; i--) {
        stack.push(children[i])  // 将子节点倒序放置栈中，保证栈顶是第一个子节点
      }
    } 
  }
  return nodeList
}
```
```js
递归写法
let deep1 = (node,nodeList = []) => {  // node是html片段,nodeList是所有节点的集合数组.
  if(node !== null) {
    nodeList.push(node);
    let children = node.children;
    for (let i = 0; i < children.length; i++){
      deep1(children[i],nodeList)
    }
  }
  return nodeList;
}
```
深度优先遍历换言之就是`一条路走到黑`直到该节点下没有子节点为止.

## 广度优先遍历
Breadth First Search(BFS)又称宽度优先遍历,和上面的深度优先遍历刚好是两个不同维度上的搜索算法.也是最基础的图算法之一,很多算法都是以BFS为原型的,如狄杰斯特拉算法求最短路径、Prim算法求最小生成树等.BFS算法是一种盲选法,是不考虑结果的一种算法.从某一顶点v起开始遍历,然后遍历与v相邻的顶点,依次访问相邻顶点,如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止.
